use std::collections::BTreeMap;
use std::fmt;

#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub enum Type {
    Tuple(Vec<Type>),
    Named(String, Vec<Type>),
    Function(Box<Type>, Box<Type>),
    Var(usize, Vec<usize>),
}

impl Type {
    pub fn contains(&self, index: usize) -> bool {
        match self {
            Type::Tuple(items) => {
                for item in items {
                    if item.contains(index) {
                        return true;
                    }
                }
                return false;
            }
            Type::Named(_, items) => {
                for item in items {
                    if item.contains(index) {
                        return true;
                    }
                }
                return false;
            }
            Type::Function(from, to) => {
                if from.contains(index) {
                    return true;
                }
                if to.contains(index) {
                    return true;
                }
                return false;
            }
            Type::Var(i, _) => {
                return *i == index;
            }
        }
    }
}

impl fmt::Display for Type {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Type::Tuple(items) => {
                let ss: Vec<_> = items.iter().map(|i| format!("{}", i)).collect();
                write!(f, "({})", ss.join(", "))
            }
            Type::Named(name, items) => {
                let ss: Vec<_> = items.iter().map(|i| format!("{}", i)).collect();
                let args = if ss.is_empty() {
                    "".to_string()
                } else {
                    format!(" ({})", ss.join(" "))
                };
                write!(f, "{}{}", name, args)
            }
            Type::Function(from, to) => write!(f, "{} -> {}", from, to),
            Type::Var(id, constraints) => {
                let c = if constraints.is_empty() {
                    format!("")
                } else {
                    format!(
                        "/{}",
                        constraints
                            .iter()
                            .map(|c| format!("{}", c))
                            .collect::<Vec<_>>()
                            .join(", ")
                    )
                };
                write!(f, "${}{}", id, c)
            }
        }
    }
}

#[derive(Debug, Eq, PartialEq)]
pub struct Substitution {
    var_map: BTreeMap<usize, Type>,
    constraints: BTreeMap<usize, Vec<Type>>,
}

impl Substitution {
    pub fn empty() -> Substitution {
        Substitution {
            var_map: BTreeMap::new(),
            constraints: BTreeMap::new(),
        }
    }

    pub fn is_empty(&self) -> bool {
        self.var_map.is_empty()
    }

    pub fn add_constraint(&mut self, class_id: usize, ty: Type) {
        let constraints = self
            .constraints
            .entry(class_id)
            .or_insert_with(|| Vec::new());
        constraints.push(ty);
    }

    pub fn add(&mut self, index: usize, ty: &Type) -> Result<(), Error> {
        if ty.contains(index) {
            Err(Error::RecursiveType)
        } else {
            let stored_ty = self.var_map.entry(index).or_insert_with(|| ty.clone());
            if stored_ty == ty {
                Ok(())
            } else {
                Err(Error::Fail)
            }
        }
    }

    pub fn dump(&self) {
        for (index, ty) in &self.var_map {
            println!("{} => {}", index, ty);
        }
        for (index, types) in &self.constraints {
            let s: Vec<_> = types.iter().map(|ty| format!("{}", ty)).collect();
            println!("class {} => ({})", index, s.join(", "));
        }
    }

    pub fn apply(&self, ty: &Type) -> Type {
        match ty {
            Type::Var(index, _) => match self.var_map.get(index) {
                Some(ty) => ty.clone(),
                None => ty.clone(),
            },
            Type::Function(ty1, ty2) => {
                Type::Function(Box::new(self.apply(ty1)), Box::new(self.apply(ty2)))
            }
            Type::Tuple(items) => {
                let items = items.iter().map(|ty| self.apply(ty)).collect();
                Type::Tuple(items)
            }
            Type::Named(n, items) => {
                let items = items.iter().map(|ty| self.apply(ty)).collect();
                Type::Named(n.clone(), items)
            }
        }
    }
}

#[derive(Debug, Eq, PartialEq)]
pub enum Error {
    Fail,
    RecursiveType,
}

fn unify(type1: &Type, type2: &Type, substitution: &mut Substitution) -> Result<(), Error> {
    match (type1, type2) {
        (Type::Named(name1, items1), Type::Named(name2, items2)) => {
            if name1 == name2 {
                assert_eq!(items1.len(), items2.len());
                for (item1, item2) in items1.iter().zip(items2.iter()) {
                    unify(item1, item2, substitution)?;
                }
                Ok(())
            } else {
                return Err(Error::Fail);
            }
        }
        (Type::Var(index, constraints), _) => {
            for c in constraints {
                substitution.add_constraint(*c, type2.clone());
            }
            return substitution.add(*index, type2);
        }
        (_, Type::Var(index, constraints)) => {
            for c in constraints {
                substitution.add_constraint(*c, type1.clone());
            }
            return substitution.add(*index, type1);
        }
        (Type::Tuple(items1), Type::Tuple(items2)) => {
            if items1.len() != items2.len() {
                return Err(Error::Fail);
            }
            for (item1, item2) in items1.iter().zip(items2.iter()) {
                unify(item1, item2, substitution)?;
            }
            Ok(())
        }
        (Type::Function(from1, to1), Type::Function(from2, to2)) => {
            unify(from1, from2, substitution)?;
            unify(to1, to2, substitution)?;
            Ok(())
        }
        _ => return Err(Error::Fail),
    }
}

fn var(index: usize) -> Type {
    Type::Var(index, vec![])
}

fn var_c(index: usize, class_id: usize) -> Type {
    Type::Var(index, vec![class_id])
}

fn fun(from: &Type, to: &Type) -> Type {
    Type::Function(Box::new(from.clone()), Box::new(to.clone()))
}

#[test]
fn unify_same() {
    let a = Type::Named("A".to_string(), vec![]);
    let b = Type::Named("A".to_string(), vec![]);
    let mut sub = Substitution::empty();
    unify(&a, &b, &mut sub).unwrap();
    assert!(sub.is_empty());
}

#[test]
fn unify_var1() {
    let v0 = var(0);
    let a = Type::Named("A".to_string(), vec![]);
    let mut sub = Substitution::empty();
    unify(&v0, &a, &mut sub).unwrap();
    let mut result_sub = Substitution::empty();
    result_sub.add(0, &a).unwrap();
    assert_eq!(sub, result_sub);
}

#[test]
fn unify_tuples() {
    let a = Type::Named("A".to_string(), vec![]);
    let b = Type::Named("B".to_string(), vec![]);
    let tuple1 = Type::Tuple(vec![a.clone(), b.clone()]);
    let tuple2 = Type::Tuple(vec![a.clone(), b.clone()]);
    let mut sub = Substitution::empty();
    unify(&tuple1, &tuple2, &mut sub).unwrap();
    assert!(sub.is_empty());
}

#[test]
fn unify_tuple_vars() {
    let v0 = var(0);
    let v1 = var(1);
    let a = Type::Named("A".to_string(), vec![]);
    let b = Type::Named("B".to_string(), vec![]);
    let tuple1 = Type::Tuple(vec![v0.clone(), v1.clone()]);
    let tuple2 = Type::Tuple(vec![a.clone(), b.clone()]);
    let mut sub = Substitution::empty();
    unify(&tuple1, &tuple2, &mut sub).unwrap();
    let mut result_sub = Substitution::empty();
    result_sub.add(0, &a).unwrap();
    result_sub.add(1, &b).unwrap();
    assert_eq!(sub, result_sub);
}

#[test]
fn unify_tuple_var_fail() {
    let v0 = var(0);
    let v1 = var(0);
    let a = Type::Named("A".to_string(), vec![]);
    let b = Type::Named("B".to_string(), vec![]);
    let tuple1 = Type::Tuple(vec![v0.clone(), v1.clone()]);
    let tuple2 = Type::Tuple(vec![a.clone(), b.clone()]);
    let mut sub = Substitution::empty();
    let r = unify(&tuple1, &tuple2, &mut sub);
    assert_eq!(r, Err(Error::Fail));
}

#[test]
fn fn_test() {
    let v2 = var(2);
    let a = Type::Named("A".to_string(), vec![]);
    let fn1 = fun(&a, &a);
    let fn2 = fun(&v2, &v2);
    let mut sub = Substitution::empty();
    unify(&fn1, &fn2, &mut sub).unwrap();
    let mut result_sub = Substitution::empty();
    result_sub.add(2, &a).unwrap();
    assert_eq!(sub, result_sub);
}

fn unify_test(ty1: &Type, ty2: &Type) {
    println!("{} =? {}", ty1, ty2);
    let mut sub = Substitution::empty();
    unify(ty1, ty2, &mut sub).unwrap();
    sub.dump();
    let ty3 = sub.apply(ty2);
    println!("Result {}", ty3);
}

fn main() {
    /*{
        let v0 = var(0);
        let v1 = var(1);
        let v2 = var(2);
        let a = Type::Named("A".to_string(), vec![]);
        let b = Type::Named("B".to_string(), vec![]);
        let fn1 = fun(&a, &fun(&a, &b));
        let fn2 = fun(&v2, &fun(&v0, &v1));
        unify_test(&fn1, &fn2);
    }*/

    {
        let v0 = var_c(0, 13);
        let fn1 = fun(&var(1), &var(2));
        println!("Input type: {}", v0);
        println!("Single arg fn: {}", fn1);
        let mut sub = Substitution::empty();
        unify(&v0, &fn1, &mut sub).unwrap();
        sub.dump();
        let fn_ty = sub.apply(&v0);
        println!("fn type: {}", fn_ty);
    }
}
